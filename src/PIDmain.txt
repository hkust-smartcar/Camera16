/*
 * main.cpp
 *
 * Author: Kyle
 * Adopted from code written by Peter
 * Copyright (c) 2015-2016 HKUST SmartCar Team
 * Refer to LICENSE for details
 */

#include <cassert>
#include <cstring>
#include <libsc/system.h>
#include <stdint.h>
#include "pVarManager.h"
#include "car.h"
#include "RunMode.h"
#include <libutil/looper.h>

using namespace libsc;

using namespace libbase::k60;

using namespace libutil;

int main(void) {

//code for ploting graph for a equation of y = mx +c, where y and x are encoder counting or motor PWM
//uncomment for usage
	/*
	 //tune encoder here
	 //to uncomment this code, comment all pVarManager object
	 JyMcuBt106::Config config;
	 config.id = 0;
	 config.baud_rate = libbase::k60::Uart::Config::BaudRate::k115200;
	 config.rx_irq_threshold = 2;
	 JyMcuBt106 fuck(config);
	 char *PWM_buffer = new char[120]{0};
	 float encoder_counting = 0;
	 int motor_speed =0;
	 while(1){
	 motor_speed += 1;
	 Run.motor_control(motor_speed,true);
	 Run.update_encoder();
	 System::DelayMs(30);
	 Run.update_encoder();

	 encoder_counting = Run.get_encoder_count();
	 int n = sprintf(PWM_buffer,"%d %d \n",(int)motor_speed,(int)encoder_counting);
	 fuck.SendBuffer((Byte*)PWM_buffer,n);
	 memset(PWM_buffer,0,n);
	 if (motor_speed > 500) {	 Run.motor_control(0,true);while(1);}
	 System::DelayMs(20);
	 }
	 */

	/*
	 to use pVarManager, you need to use Chrome to download the app by peter
	 link:
	 https://chrome.google.com/webstore/search/pgrapher?utm_source=chrome-ntp-icon
	 */

//-------------------------------------your code below----------------------------------------//
	System::Init();
//	Car car;
	RunMode Kyle;
	//MUST initialize for using LCD and anything that contain function inside "System"
	//use tick
	//...
	int pwr = 200;
	volatile Timer::TimerInt t = 20;

	Button::Config btncfg;
	btncfg.is_active_low = true;
	btncfg.is_use_pull_resistor = false;
	btncfg.id = 0;
	btncfg.listener_trigger = Button::Config::Trigger::kDown;
	btncfg.listener = [&](const uint8_t)
	{
		pwr+=10;
		Kyle.beepbuzzer(100);
	};
	Button but0(btncfg);
	btncfg.id = 1;
	btncfg.listener_trigger = Button::Config::Trigger::kDown;
	btncfg.listener = [&](const uint8_t)
	{
		pwr-=10;
		Kyle.beepbuzzer(100);
	};
	Button but1(btncfg);

	Joystick::Config fwaycfg;
	fwaycfg.id = 0;
	fwaycfg.listener_triggers[static_cast<int>(Joystick::State::kUp)] =
			Joystick::Config::Trigger::kDown;
	fwaycfg.listeners[static_cast<int>(Joystick::State::kUp)] =
			[&](const uint8_t)
			{
				t+=1;
				Kyle.beepbuzzer(100);
			};
	fwaycfg.listener_triggers[static_cast<int>(Joystick::State::kDown)] =
			Joystick::Config::Trigger::kDown;
	fwaycfg.listeners[static_cast<int>(Joystick::State::kDown)] =
			[&](const uint8_t)
			{
				t-=1;
				Kyle.beepbuzzer(100);
			};

	Joystick joy(fwaycfg);

	Looper looper;

	Looper::Callback testPID = [&](const Timer::TimerInt, const Timer::TimerInt)
	{
		Kyle.GetMotor().SetPower(pwr);
		Kyle.printvalue(0,0,80,50,pwr,0xFFFF);
		Kyle.GetEnc().Update();
		Kyle.printvalue(0,50,80,50,Kyle.GetEnc().GetCount(),0xFFFF);
		Kyle.printvalue(0,100,80,50,t,0xFFFF);
		looper.RunAfter(t, testPID);
	};

	looper.RunAfter(t, testPID);
	looper.Loop();

	for (;;) {
	}
	looper.~Looper();
	Kyle.~RunMode();
	return 0;
}
